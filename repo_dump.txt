
===== combat.js =====
import { CARDS }                           from './data.js';
import { G, newUnit, living, tauntOf,
         shuffle, rand, polBonus,
         polAvg, resetCombatState,
         cloneUnit }                        from './state.js';
import { render }                           from './render.js';
import { processLevelQueue }               from './flow.js';
import { resetFluxState }                  from './conductor.js';
import { applyBossEffect }                 from './opponents.js';

// â”€â”€ CONSTANTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const WINDOW_MS = 3200;
let _tick = null;
export function clearTick() { clearTimeout(_tick); }

// â”€â”€ POLARITY RULE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function activeRule(board) {
  const avg = polAvg(board);
  if (avg < 35)  return 'order';
  if (avg > 65)  return 'chaos';
  return 'flux';
}

// â”€â”€ TARGET SELECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pickTarget(targetBoard) {
  return tauntOf(targetBoard) || living(targetBoard)[0];
}

function sortedLiving(board) {
  const l = living(board);
  return [
    ...l.filter(u => u.kw === 'haste'),
    ...l.filter(u => u.kw !== 'haste'),
  ];
}

// â”€â”€ TIMER BAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function startTimer() {
  const f = document.getElementById('timerfill');
  f.style.transition = 'none';
  f.style.width = '100%';
  requestAnimationFrame(() => requestAnimationFrame(() => {
    f.style.transition = `width ${WINDOW_MS}ms linear`;
    f.style.width = '0%';
  }));
}

export function stopTimer() {
  const f = document.getElementById('timerfill');
  f.style.transition = 'none';
  f.style.width = '0%';
}

// â”€â”€ COMBAT ENTRY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function startCombat() {
  if (!G.pboard.length) return;

  G.pboardSnapshot = G.pboard.map(cloneUnit);

  const pb = polBonus(G.pboard);
  const eb = polBonus(G.eboard);

  resetCombatState();
  resetFluxState();

  const bossLog = applyBossEffect(G.round);

  // â”€â”€ Build player combat copies, applying entropy penalties â”€â”€
  const entropyWarnings = [];
  G.cb.pb = G.pboard.map(u => {
    const ent = u.entropy || 0;
    if (ent >= 5) {
      entropyWarnings.push(`${u.name} collapses â€” entropy overwhelming.`);
      return {
        ...cloneUnit(u),
        chp:   0,
        maxhp: u.maxhp + pb.hp,
        atk:   u.atk + pb.atk,
        dead:  true,
      };
    }
    const atkPenalty = ent >= 3 ? 1 : 0;
    return {
      ...cloneUnit(u),
      chp:   u.chp   + pb.hp,
      maxhp: u.maxhp + pb.hp,
      atk:   Math.max(0, u.atk + pb.atk - atkPenalty),
      dead:  false,
    };
  });

  G.cb.eb = G.eboard.map(u => ({
    ...cloneUnit(u),
    chp:   u.chp   + eb.hp,
    maxhp: u.maxhp + eb.hp,
    atk:   u.atk   + eb.atk,
    dead:  false,
  }));

  // Armed card becomes the hand for this combat
  G.chand = G.armedCard ? [G.armedCard] : [shuffle(CARDS)[0]];
  G.cused = false;
  G.csel  = null;
  G.phase = 'combat';

  const rule    = activeRule(G.pboard);
  const ruleMsg = {
    order: 'ORDER active â€” formation engaged.',
    chaos: 'CHAOS active â€” chain kills enabled.',
    flux:  'FLUX active â€” first Redirect is free.',
  };

  G.cb.log = entropyWarnings.length
    ? entropyWarnings.join(' ')
    : bossLog ?? ruleMsg[rule];

  render();
  _tick = setTimeout(tick, 1200);
}

// â”€â”€ TICK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function tick() {
  const pa = sortedLiving(G.cb.pb);
  const ea = sortedLiving(G.cb.eb);
  if (!pa.length || !ea.length) { endCombat(); return; }

  const t     = G.cb.tickIdx;
  const pturn = (t % 2 === 0);
  G.cb.pturn  = pturn;

  const att = pturn
    ? pa[Math.floor(t / 2) % pa.length]
    : ea[Math.floor(t / 2) % ea.length];
  const tgt = pturn
    ? pickTarget(G.cb.eb)
    : pickTarget(G.cb.pb);

  G.cb.attacker = att;
  G.cb.target   = tgt;
  G.cb.log      = `${att.name} â†’ ${tgt.name}â€¦`;
  G.cb.tag      = pturn ? 'âš” Your attack' : 'âš” Enemy attack';
  G.cb.window   = true;
  G.cb.tickIdx++;

  render();
  startTimer();

  _tick = setTimeout(() => {
    G.cb.window = false;
    G.csel = null;
    render();
    resolve();
  }, WINDOW_MS);
}

// â”€â”€ RESOLVE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function resolve() {
  const { attacker: att, target: tgt } = G.cb;

  if (!att || !tgt || tgt.dead || att.dead) {
    G.cb.log = 'â€”'; G.cb.tag = '';
    G.cb.attacker = null; G.cb.target = null;
    render();
    _tick = setTimeout(tick, 600);
    return;
  }

  const rule = activeRule(G.pboard);
  const dA   = att.atk;
  const dB   = tgt.atk + (tgt.kw === 'retaliate' ? 1 : 0);

  tgt.chp -= dA;
  att.chp -= dB;
  G.cb.flashUids = [tgt.uid, att.uid];

  if (tgt.chp <= 0 && att.kw === 'leech') att.chp = Math.min(att.maxhp, att.chp + 1);
  if (att.chp <= 0 && tgt.kw === 'leech') tgt.chp = Math.min(tgt.maxhp, tgt.chp + 1);

  const tgtDied = tgt.chp <= 0;
  const attDied = att.chp <= 0;
  if (tgtDied) tgt.dead = true;
  if (attDied) att.dead = true;

  const retNote = tgt.kw === 'retaliate' ? ' (Retaliate +1)' : '';
  if      (attDied && tgtDied) G.cb.log = `Both ${att.name} and ${tgt.name} fall.`;
  else if (attDied)            G.cb.log = `${att.name} destroys ${tgt.name} but falls to the counter${retNote}.`;
  else if (tgtDied)            G.cb.log = `${att.name} slays ${tgt.name} (${dA} dealt, ${dB} taken${retNote}).`;
  else                         G.cb.log = `${att.name} deals ${dA}, takes ${dB}${retNote} â€” ${att.chp} vs ${tgt.chp} HP.`;

  if (rule === 'chaos' && tgtDied && !attDied) {
    const nextTarget = pickTarget(G.cb.pturn ? G.cb.eb : G.cb.pb);
    if (nextTarget) {
      const chainDmg = att.atk;
      nextTarget.chp -= chainDmg;
      if (nextTarget.chp <= 0) nextTarget.dead = true;
      G.cb.log += ` [chain] â†’ ${nextTarget.name} (${chainDmg}).`;
      G.cb.flashUids.push(nextTarget.uid);
    }
  }

  G.cb.tag      = '';
  G.cb.attacker = null;
  G.cb.target   = null;
  G.cb.window   = false;

  render();
  setTimeout(() => { G.cb.flashUids = []; }, 400);
  _tick = setTimeout(tick, 900);
}

// â”€â”€ END COMBAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function endCombat() {
  clearTimeout(_tick);
  stopTimer();

  const pa = living(G.cb.pb);
  const ea = living(G.cb.eb);

  let res;
  if      (pa.length && !ea.length) { res = 'win';  G.cb.log = 'Victory â€” your board holds.'; }
  else if (ea.length && !pa.length) { res = 'loss'; G.cb.log = 'Defeat. Entropy spreads.'; }
  else                              { res = 'draw'; G.cb.log = 'Draw â€” both sides fall.'; }

  G.cb.result = res;
  G.cb.over   = true;
  G.levelQueue = [];

  if (res === 'win') {
    G.cb.pb.forEach(cu => {
      const u = G.pboard.find(x => x.uid === cu.uid);
      if (!u) return;
      u.chp  = cu.chp;
      u.dead = cu.dead;
      if (!cu.dead && cu.chp > 0) {
        u.xp = (u.xp || 0) + 1;
        if (u.xp >= 2) { u.xp = 0; G.levelQueue.push(u); }
      }
    });
    G.pboard = G.pboard.filter(u => !u.dead && u.chp > 0);

  } else if (res === 'loss') {
    const dmg = ea.reduce((s, u) => s + u.atk, 0);
    G.hp = Math.max(0, G.hp - dmg);
    G.cb.pb.forEach(cu => {
      const u = G.pboard.find(x => x.uid === cu.uid);
      if (!u) return;
      u.chp     = cu.chp;
      u.dead    = cu.dead;
      u.entropy = (u.entropy || 0) + 2;
    });
    G.pboard = G.pboard.filter(u => !u.dead && u.chp > 0);

  } else {
    G.pboard = G.pboardSnapshot;
  }

  // â”€â”€ Armed card: discard if played, retain if held â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (G.cused) G.armedCard = null;

  G.phase = 'result';
  render();

  setTimeout(() => {
    if (G.hp <= 0) {
      showResult('Eliminated', 'loss', 'Your HP reached zero. Refresh to begin again.', true);
      return;
    }
    const msgs = {
      win:  ['Victory', 'Survivors carry their HP forward.'],
      loss: ['Defeat',  'You lose HP. Entropy marks your survivors.'],
      draw: ['Draw',    'Both armies fall. Your board is restored.'],
    };
    const [title, sub] = msgs[res];
    showResult(title, res, sub, false);
  }, 700);
}

// â”€â”€ RESULT OVERLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showResult(title, cls, sub, eliminated) {
  document.getElementById('rtitle').textContent  = title;
  document.getElementById('rtitle').className    = `rtitle ${cls}`;
  document.getElementById('rsub').textContent    = sub;
  document.getElementById('rbtn').style.display  = eliminated ? 'none' : '';
  document.getElementById('overlay').style.display = 'flex';
}

// â”€â”€ ENEMY ROSTER BUILDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import { POOL, ENEMY_BASES } from './data.js';

export function buildEnemyRoster(round) {
  const idx    = Math.min(round - 1, ENEMY_BASES.length - 1);
  const atkBon = Math.max(0, round - 1);
  const hpBon  = Math.floor(atkBon / 2);
  return ENEMY_BASES[idx].map(id => {
    const base = POOL.find(u => u.id === id);
    return newUnit({
      ...base,
      atk: base.atk + atkBon,
      hp:  base.hp  + hpBon,
    });
  });
}
===== conductor.js =====
import { CARDS }                        from './data.js';
import { G, rand, living }             from './state.js';
import { render }                      from './render.js';
import { resolve, stopTimer, clearTick,
         activeRule, WINDOW_MS }       from './combat.js';

// â”€â”€ ARM CARD (shop phase) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Called when the player chooses one of the three offered cards.
export function armCard(cardId) {
  if (G.phase !== 'shop' || G.armedCard) return;
  const card = CARDS.find(c => c.id === cardId);
  if (!card) return;
  G.armedCard   = card;
  G.cardOptions = [];
  render();
}

// â”€â”€ HOLD ACTION (combat window) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Player passes on intervention and claims a reward instead.
// The window timer continues; this merely banks the reward.
export function holdAction(choice) {
  if (!G.cb.window || G.cused || G.cb.holdUsed) return;
  if (choice === 'gold')    G.pendingGold += 1;
  if (choice === 'insight') G.insight = Math.min(2, G.insight + 1);
  G.cb.holdUsed = true;
  G.cb.log = choice === 'gold'
    ? 'Held â€” +1 Gold banked for next round.'
    : 'Held â€” +1 Insight stored.';
  render();
}

// â”€â”€ CONDUCT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function conduct(cardId, targetUid) {
  if (G.cused) return;

  const card = CARDS.find(c => c.id === cardId);
  if (!card) return;

  const pb = G.cb.pb;
  const eb = G.cb.eb;

  // â”€â”€ Redirect â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (card.id === 'redirect') {
    if (!G.cb.window || !G.cb.pturn || !G.cb.attacker) {
      G.cb.log = 'Redirect only works during your attack window.';
      G.csel = null;
      render();
      return;
    }
    const nt = eb.find(u => u.uid === targetUid && !u.dead);
    if (!nt) return;

    clearTick();
    stopTimer();

    G.cb.target = nt;
    G.cb.log    = `Redirected â€” ${G.cb.attacker.name} now strikes ${nt.name}â€¦`;
    G.cb.window = false;

    const free = (activeRule(G.pboard) === 'flux' && !G._fluxRedirectUsed);
    if (free) {
      G._fluxRedirectUsed = true;
      G.cb.log += ' [free â€” Flux]';
    } else {
      G.cused = true;
      G.heat  = Math.min(3, G.heat + 1);
    }

    G.csel = null;
    render();
    setTimeout(resolve, 800);
    return;
  }

  // â”€â”€ Targeting friction: Bulwark and Surge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Only the front two board positions may be targeted.
  if (card.id === 'bulwark' || card.id === 'surge') {
    const frontUids = pb.slice(0, 2).map(u => u.uid);
    if (!frontUids.includes(targetUid)) {
      G.cb.log = `${card.name} only reaches the front two units.`;
      G.csel = null;
      render();
      return;
    }
  }

  // â”€â”€ Bulwark â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (card.id === 'bulwark') {
    const u = pb.find(u => u.uid === targetUid && !u.dead);
    if (u) { u.chp += 3; u.maxhp += 3; G.cb.log = `Bulwark â€” ${u.name} +3 HP.`; }
  }

  // â”€â”€ Surge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (card.id === 'surge') {
    const u = pb.find(u => u.uid === targetUid && !u.dead);
    if (u) { u.atk += 2; G.cb.log = `Surge â€” ${u.name} +2 ATK.`; }
  }

  // â”€â”€ Drain â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (card.id === 'drain') {
    let rem = 3;
    while (rem > 0 && living(eb).length) {
      const t = rand(living(eb));
      const d = Math.min(2, rem);
      t.chp -= d;
      rem   -= d;
      if (t.chp <= 0) t.dead = true;
    }
    G.cb.log = 'Drain â€” 3 damage scattered among enemies.';
  }

  // â”€â”€ Unravel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (card.id === 'unravel') {
    const pu = G.pboard.find(u => u.uid === targetUid);
    if (pu) {
      pu.entropy  = Math.max(0, pu.entropy - 3);
      G.cb.log    = `Unravel â€” entropy cleared from ${pu.name}.`;
    }
  }

  G.cused = true;
  G.heat  = Math.min(3, G.heat + 1);
  G.csel  = null;
  render();
}

// â”€â”€ FLUX STATE RESET â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function resetFluxState() {
  G._fluxRedirectUsed = false;
}

// â”€â”€ CARD SELECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function selectCard(cardId) {
  if (G.cused) return;
  const card = CARDS.find(c => c.id === cardId);
  if (!card) return;

  if (card.tgt === null) {
    conduct(cardId, null);
    return;
  }

  G.csel = G.csel?.id === cardId ? null : card;
  render();
}

// â”€â”€ TARGET CLICK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function targetClick(uid, isEnemy) {
  if (!G.csel || G.cused) return;
  const validEnemy    = G.csel.tgt === 'enemy'    &&  isEnemy;
  const validFriendly = G.csel.tgt === 'friendly' && !isEnemy;
  if (validEnemy || validFriendly) conduct(G.csel.id, uid);
}
===== data.js =====
// â”€â”€ KEYWORDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Display metadata only. Combat behaviour lives in combat.js.
export const KW = {
  taunt:     { label: 'Taunt',     cls: 'kw-taunt'     },
  haste:     { label: 'Haste',     cls: 'kw-haste'     },
  retaliate: { label: 'Retaliate', cls: 'kw-retaliate' },
  leech:     { label: 'Leech',     cls: 'kw-leech'     },
};

// â”€â”€ UNIT POOL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// tier 1 = always available; tier 2 = unlocked after tavern upgrade.
// stat budget heuristic: cost-2 â‰ˆ 5pts, cost-3 â‰ˆ 7pts+kw, cost-4 â‰ˆ 9pts+kw
export const POOL = [
  { id: 'rifter',     name: 'Rifter',     atk: 2, hp: 3, pol: 50, sym: 'â—ˆ', cost: 2, kw: null,        tier: 1 },
  { id: 'tendril',    name: 'Tendril',    atk: 1, hp: 5, pol: 75, sym: 'â‹', cost: 2, kw: null,        tier: 1 },
  { id: 'voltspawn',  name: 'Voltspawn',  atk: 3, hp: 2, pol: 85, sym: 'âš¡', cost: 3, kw: 'haste',    tier: 1 },
  { id: 'stoneguard', name: 'Stoneguard', atk: 1, hp: 6, pol: 15, sym: 'â¬¡', cost: 3, kw: 'taunt',    tier: 1 },
  { id: 'prismcore',  name: 'Prismcore',  atk: 2, hp: 4, pol: 50, sym: 'â—‡', cost: 3, kw: 'retaliate', tier: 1 },
  { id: 'ironwarden', name: 'Ironwarden', atk: 2, hp: 5, pol: 20, sym: 'â–£', cost: 3, kw: 'taunt',    tier: 1 },
  { id: 'wraithclaw', name: 'Wraithclaw', atk: 4, hp: 3, pol: 10, sym: 'âœ¦', cost: 4, kw: 'leech',    tier: 2 },
  { id: 'voidmaw',    name: 'Voidmaw',    atk: 5, hp: 2, pol: 90, sym: 'â—‰', cost: 4, kw: 'haste',    tier: 2 },
  { id: 'soulbinder', name: 'Soulbinder', atk: 3, hp: 4, pol: 55, sym: 'âŒ¬', cost: 4, kw: 'leech',    tier: 2 },
  { id: 'nullspike',  name: 'Nullspike',  atk: 4, hp: 3, pol: 45, sym: 'âœ§', cost: 4, kw: 'retaliate', tier: 2 },
];

// â”€â”€ CONDUCTOR CARDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// tgt: 'enemy' | 'friendly' | null (no target required)
export const CARDS = [
  { id: 'redirect', name: 'Redirect', sym: 'â†º', desc: 'During your attack window: retarget to another enemy',  tgt: 'enemy'    },
  { id: 'bulwark',  name: 'Bulwark',  sym: 'â›¨', desc: 'Give a friendly unit +3 HP',                            tgt: 'friendly' },
  { id: 'surge',    name: 'Surge',    sym: 'â†‘', desc: 'Give a friendly unit +2 ATK this combat',                tgt: 'friendly' },
  { id: 'drain',    name: 'Drain',    sym: 'â—', desc: 'Deal 3 damage spread across random enemies',             tgt: null       },
  { id: 'unravel',  name: 'Unravel',  sym: 'â‰‹', desc: 'Remove 3 entropy from a friendly unit',                 tgt: 'friendly' },
];

// â”€â”€ ENEMY ROSTERS (base, before round scaling) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// combat.js applies per-round ATK/HP bonuses on top of these.
export const ENEMY_BASES = [
  ['tendril', 'stoneguard'],
  ['voltspawn', 'rifter', 'tendril'],
  ['wraithclaw', 'ironwarden', 'prismcore'],
  ['voidmaw', 'stoneguard', 'wraithclaw'],
  ['voidmaw', 'nullspike', 'ironwarden', 'soulbinder'],
];

// â”€â”€ TUTORIAL STEPS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const TUTORIAL = [
  {
    title: 'The Shop',
    body: '<strong>Buy units</strong> with ğŸª™ gold (up to your board cap). Hover a board unit and click <strong>sell</strong> to reclaim 1 gold. Each card shows its polarity strip and keyword. Use <strong>Reroll</strong> (1ğŸª™) for a fresh shop, or <strong>Upgrade Tavern</strong> (4ğŸª™) to unlock a 5th board slot and rarer units.',
  },
  {
    title: 'Incoming Damage',
    body: 'The topbar shows <strong>âš” If you lose: N dmg</strong> â€” the sum of all surviving enemy ATK. That number updates every round. It tells you exactly how much a loss will cost, so every purchase is a legible trade-off.',
  },
  {
    title: 'Keywords',
    body: `<span class="kw-inline kw-taunt">Taunt</span> must be attacked first &nbsp;
<span class="kw-inline kw-haste">Haste</span> attacks before others<br>
<span class="kw-inline kw-retaliate">Retaliate</span> deals +1 counter-damage &nbsp;
<span class="kw-inline kw-leech">Leech</span> heals 1 on kill<br><br>
Two cheap Rifters trade evenly. A Stoneguard with <strong>Taunt</strong> controls who takes the hits.`,
  },
  {
    title: 'Unit XP & Level-Up',
    body: 'Every unit that <strong>survives a combat</strong> gains 1 XP. At 2 XP it levels up â€” you choose <strong>+1 ATK</strong> or <strong>+1 HP</strong>. A levelled unit is worth protecting. Selling a Lv2 unit is a real sacrifice.',
  },
];
===== flow.js =====
import { G } from './state.js';

// startRound is registered here by shop.js on init,
// avoiding a circular dep (flow â†’ shop â†’ flow).
let _startRound = null;
export function registerStartRound(fn) { _startRound = fn; }

// â”€â”€ LEVEL-UP QUEUE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Called after the result overlay is dismissed (via onContinue).
// Works through G.levelQueue one unit at a time, showing a modal
// for each. When the queue is empty, advances to the next round.
export function processLevelQueue() {
  if (!G.levelQueue.length) {
    G.round++;
    _startRound?.();
    return;
  }
  const u = G.levelQueue[0];
  document.getElementById('luname').textContent = `${u.name} reached Level ${u.lv + 1}`;
  document.getElementById('levelup').style.display = 'flex';
}

export function applyLevelUp(choice) {
  const u = G.levelQueue.shift();
  if (u) {
    u.lv = (u.lv || 1) + 1;
    if (choice === 'atk') {
      u.atk += 1;
    } else {
      u.hp   += 1;
      u.chp   = Math.min(u.chp + 1, u.hp);
      u.maxhp = u.hp;
    }
  }
  document.getElementById('levelup').style.display = 'none';
  processLevelQueue();
}

// â”€â”€ CONTINUE BUTTON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Wired to the result overlay's Continue button in index.html.
export function onContinue() {
  document.getElementById('overlay').style.display = 'none';
  processLevelQueue();
}
===== handover.txt =====
# CONDUCTOR â€” Re-entry Document
# Generated end of session. Paste this at the top of the next conversation.

## WHAT THIS PROJECT IS
A solo-dev browser autobattler (working title: Conductor).
Core differentiator: a timed intervention window during combat where the
player plays one "Conductor card" (redirect, buff, drain, etc.).
Everything else serves that one mechanic.

## CURRENT FILE STRUCTURE
```
conductor/
â”œâ”€â”€ index.html        # Shell, <script type="module">, all CSS removed to styles.css
â”œâ”€â”€ styles.css        # All styles incl. .uimg, .simg, .cimg (pixelated art)
â”œâ”€â”€ data.js           # POOL, CARDS, KW, ENEMY_BASES, TUTORIAL (pure data)
â”œâ”€â”€ state.js          # G object, newUnit, helpers (polBonus, polColor, etc.)
â”œâ”€â”€ flow.js           # processLevelQueue, applyLevelUp, onContinue, registerStartRound
â”œâ”€â”€ combat.js         # tick, resolve, endCombat, startCombat, buildEnemyRoster
â”œâ”€â”€ conductor.js      # conduct, selectCard, targetClick, resetFluxState
â”œâ”€â”€ shop.js           # buildShop, startRound, buyUnit, sellUnit, reroll, upgradeTavern
â”œâ”€â”€ render.js         # render, initEvents, all DOM writes (reads G, never writes it)
â”œâ”€â”€ opponents.js      # buildGhostBoard, scout, initRoundOpponents, applyBossEffect
â”œâ”€â”€ tutorial.js       # initTutorial, renderStep, advance
â””â”€â”€ assets/
    â”œâ”€â”€ units/        # {id}.png, 64x64px pixel art, image-rendering:pixelated
    â””â”€â”€ cards/        # {id}.png, 64x64px pixel art
```

## KEY DESIGN DECISIONS
- G is a single global state object in state.js. render.js reads it, never writes.
- All event delegation lives in render.js:initEvents (one listener on document).
- flow.js is the post-combat coordinator; breaks circular dep between combat/conductor.
- shop.js:startRound() registers itself with flow.js via registerStartRound() on load.
- combat.js:resolve() applies polarity rules (ORDER/CHAOS/FLUX) inline.
- opponents.js:buildGhostBoard() generates procedural enemies; boss rounds use
  hand-authored BOSSES dict. Boss pre-combat effect applied in startCombat().
- Art: <img onerror> falls back to unicode sym if PNG missing.
- Run http.server or npx serve (ES modules require HTTP, not file://).

## CURRENT GAME SYSTEMS (WORKING)
- Shop: buy/sell/reroll(1g)/upgrade-tavern(4gâ†’tier2, 5th slot)
- 10 units: Rifter, Tendril, Voltspawn, Stoneguard, Prismcore, Ironwarden,
            Wraithclaw, Voidmaw, Soulbinder, Nullspike
- Keywords: Taunt (must target), Haste (attacks first), Retaliate (+1 counter),
            Leech (heal 1 on kill)
- Polarity: board avg < 35 = ORDER (formation), > 65 = CHAOS (chain kill),
            35-65 = FLUX (first Redirect free). Stat bonus: +2 ATK or +2 HP.
- Combat: simultaneous damage trades, left-to-right, haste first, taunt override
- Intervention window: 3.2s pause, timer bar drains, cards glow green
- 5 conductor cards: Redirect, Bulwark, Surge, Drain, Unravel
- Unit XP: survive combat = +1 XP, shown as "0/2 XP". At 2 XP: level-up modal
           (choose +1 ATK or +1 HP). Dead units do NOT gain XP.
- Scaling: enemies +1 ATK and +0.5 HP per round, no ceiling
- Ghost boards: budget = round * 2.5g. Tier 2 pool unlocks at round 4.
- Bosses: Round 5 = Iron Conductor (Drain 3 to all player units pre-combat)
          Round 9 = Void Engine (Surge strongest enemy unit pre-combat)
          Warning shown one round ahead in topbar.
- Threat preview: topbar shows "âš” If you lose: N dmg" during shop phase
- Level-up buttons: fixed to use e.target.closest() not e.target.id ===

## KNOWN REMAINING BUGS / GAPS
- No healing mechanic: injured units are best sold rather than protected.
  This undermines the XP/investment system.
- Enemy scaling has no ceiling and no player catch-up beyond tier-up.
- Entropy tokens exist visually but have no mechanical effect yet.
- Snapshot ghosts (rounds 5-8 drawing from player's past boards) not yet built.
- Formation (front/back rows) planned but not yet implemented.

## NEXT FEATURE: INTERVENTION ECONOMY v1
Agreed with both ChatGPT and Claude. Implement in this order:

### 1. ARM SYSTEM (shop phase)
- During shop, player is offered 3 cards; must choose 1 to "arm".
- Armed card shown face-up near Conductor label in topbar/shop.
- In combat: player may only play the armed card OR Hold.
- If player Intervenes: armed card is discarded after combat (re-arm next round).
- If player Holds: armed card is RETAINED for next combat (does not discard).
- State: G.armedCard (card object or null), G.cardOptions (array of 3).

### 2. HOLD REWARD (combat window)
- During window: show two buttons alongside cards: "HOLD â†’" with two reward choices:
    A) +1 Gold (applied at start of next shop phase)
    B) +1 Insight token (new micro-resource, cap 2)
- Insight can be spent in shop for: free Freeze OR free Reroll (one action, once).
- State: G.pendingGold (int), G.insight (int, 0-2).
- Intervening forfeits Hold reward for that window.
- UI: Hold buttons only visible during window and only if not yet used this combat.

### 3. TARGETING FRICTION
- Bulwark and Surge can only target units in the FRONT ROW (or adjacent to attacker
  once formation is implemented). For now: first two units on board (index 0-1).
- This is a target filter in conductor.js:conduct(), not a new system.

### 4. HEAT (implement after above three are stable)
- Using intervention adds +1 Heat (G.heat, cap 3, shown in topbar).
- Heat effect: next enemy roster gets +Heat ATK on top of normal scaling.
- Heat decays -1 per round at start of shop phase.
- Holding does not add Heat.

## AGREED DESIGN PRINCIPLES (from ChatGPT + Claude session)
- Skip/Hold must have a future plan attached, not a passive refund.
- Armed card persisting on Hold creates "threat" not just "tool".
- Window is a chess pause, never a reflex test. No APM optimization.
- Failure states should create interesting pivots (not yet implemented).
- Depth > breadth. No new content until existing systems are legible.

## ACCEPTANCE TESTS FOR INTERVENTION ECONOMY v1
- There are fights where correct play is Hold, even when HP could be saved.
- Arming a card produces planning ("I arm Surge because next fight has Taunt wall").
- At least once per run, armed card is carried across multiple combats.
- "Buff weakest" is no longer always available (targeting friction).

## CONTENT TARGETS (not yet built, for reference)
- 40 units total (10 built), 3 Conductor identities, 8 module types
- Round 5 and Round 9 bosses (built), Round 10 = escape/win condition
- Reroll token (Insight sink), Freeze button (0g, lock shop to next round)
- Healing: 1g = +1 HP on a unit (capped at maxhp) â€” highest priority gap

## HOW TO RUN
```bash
cd conductor
python -m http.server 8000
# open http://localhost:8000
```
===== index.html =====
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CONDUCTOR</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>

<!-- TOPBAR -->
<div id="topbar">
  <div class="title">Conductor</div>
  <div class="stats">
    <div class="stat"><span class="sicon">â™¥</span><span class="sval" id="shp">30</span></div>
    <div class="stat"><span class="sicon">â—ˆ</span><span class="sval" id="srd">Round 1</span></div>
    <div class="stat" id="sgwrap">
      <span class="sicon">ğŸª™</span><span class="sval" id="sgold">3</span>
    </div>
    <!-- Insight: shown when > 0 -->
    <div class="stat" id="sinsight-wrap" style="display:none">
      <span class="sicon" style="color:var(--entropy)">â—ˆ</span>
      <span class="sval" id="sinsight" style="color:var(--entropy)">0</span>
    </div>
    <!-- Heat: shown when > 0 -->
    <div class="stat" id="sheat-wrap" style="display:none">
      <span class="sicon" style="color:var(--chaos)">ğŸ”¥</span>
      <span class="sval" id="sheat" style="color:var(--chaos)">0</span>
    </div>
    <div class="threat hidden" id="threat">
      âš” If you lose: <span id="threatval">0</span> dmg
    </div>
    <div class="boss-warn" id="bosswarn"></div>
    <div class="polmeter" id="polmeter" style="display:none">
      <span style="font-size:.7em;color:var(--dim)">Board:</span>
      <div class="poltrack"><div class="polfill" id="polfill"></div></div>
      <span class="pollabel" id="pollabel">â€”</span>
      <span class="polbonus" id="polbonus"></span>
    </div>
  </div>
  <div class="pill pill-shop" id="sphase">Shop</div>
</div>

<!-- MAIN -->
<div id="main">
  <div>
    <div class="blabel">Opponent</div>
    <div class="board" id="eboard"></div>
  </div>
  <div id="logbar">
    <div id="timertrack"><div id="timerfill"></div></div>
    <div id="loginner">
      <span class="logtext" id="ltext">â€”</span>
      <span class="logtag"  id="ltag"></span>
    </div>
  </div>
  <div>
    <div class="blabel">Your Board</div>
    <div class="board" id="pboard"></div>
  </div>
  <div id="bottom">
    <div id="shop"></div>
    <div id="conductor" style="display:none"></div>
  </div>
</div>

<!-- RESULT OVERLAY -->
<div id="overlay">
  <div class="rtitle" id="rtitle"></div>
  <div class="rsub"   id="rsub"></div>
  <button class="btn primary" id="rbtn">Continue</button>
</div>

<!-- LEVEL-UP OVERLAY -->
<div id="levelup">
  <div class="lubox">
    <div class="lutitle">â¬¡ Unit Levelled Up</div>
    <div class="lusub" id="luname"></div>
    <div class="luchoices">
      <div class="luchoice" id="lu-atk">
        <div class="luchoice-icon">âš”</div>
        <div class="luchoice-label">+1 ATK</div>
        <div class="luchoice-desc">Strike harder</div>
      </div>
      <div class="luchoice" id="lu-hp">
        <div class="luchoice-icon">â™¥</div>
        <div class="luchoice-label">+1 HP</div>
        <div class="luchoice-desc">Endure longer</div>
      </div>
    </div>
  </div>
</div>

<!-- TUTORIAL OVERLAY -->
<div id="tutorial">
  <div class="tbox">
    <div class="tstep"  id="tstep"></div>
    <div class="ttitle" id="ttitle"></div>
    <div class="tbody"  id="tbody"></div>
    <div class="tfoot">
      <div class="tdots" id="tdots"></div>
      <button class="btn primary" id="tnext">Next â†’</button>
    </div>
  </div>
</div>

<!-- BOOTSTRAP -->
<script type="module">
  import { initStarterBoard }   from './state.js';
  import { startRound }         from './shop.js';
  import { initTutorial }       from './tutorial.js';
  import { render, initEvents } from './render.js';
  import { onContinue,
           applyLevelUp }       from './flow.js';

  initStarterBoard();
  startRound();
  initTutorial();
  initEvents({ onContinue, applyLevelUp });
</script>
</body>
</html>
===== opponents.js =====
import { POOL }                  from './data.js';
import { G, newUnit, shuffle }  from './state.js';
import { render }               from './render.js';

// â”€â”€ BOSS DEFINITIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BOSSES = {
  5: {
    name:    'The Iron Conductor',
    warning: 'Boss incoming â€” opens with Drain (3 dmg to all your units).',
    roster:  ['ironwarden', 'stoneguard', 'prismcore', 'voltspawn'],
    effect(pb) {
      pb.forEach(u => { u.chp = Math.max(1, u.chp - 3); });
    },
    effectLog: 'The Iron Conductor opens â€” Drain strikes all your units for 3.',
  },
  9: {
    name:    'The Void Engine',
    warning: 'Boss incoming â€” opens with Surge on its strongest unit.',
    roster:  ['voidmaw', 'nullspike', 'wraithclaw', 'soulbinder'],
    effect(pb, eb) {
      const strongest = [...eb].sort((a, b) => b.atk - a.atk)[0];
      if (strongest) strongest.atk += 2;
    },
    effectLog: 'The Void Engine opens â€” its strongest unit surges to +2 ATK.',
  },
};

// â”€â”€ BOSS CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function isBossRound(round) { return round in BOSSES; }
export function getBoss(round)     { return BOSSES[round] ?? null; }

// â”€â”€ GHOST BOARD GENERATOR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BUDGET_PER_ROUND = 2.5;

export function buildGhostBoard(round) {
  const boss = getBoss(round);
  if (boss) {
    return boss.roster.map(id => scaledUnit(POOL.find(u => u.id === id), round));
  }

  const budget    = Math.round(round * BUDGET_PER_ROUND);
  const tierLimit = round >= 4 ? 2 : 1;
  const pool      = shuffle(POOL.filter(u => u.tier <= tierLimit));
  const roster    = [];
  let   spent     = 0;

  for (const template of pool) {
    if (roster.length >= 4) break;
    if (spent + template.cost <= budget) {
      roster.push(scaledUnit(template, round));
      spent += template.cost;
    }
  }

  if (!roster.length) roster.push(scaledUnit(pool[0], round));

  return roster;
}

// Apply per-round ATK/HP scaling plus current Heat bonus.
// Heat is read from G at build time (enemies are built at round start,
// after the previous combat's interventions have raised G.heat).
function scaledUnit(template, round) {
  const baseAtk = Math.max(0, round - 1);
  const hpBon   = Math.floor(baseAtk / 2);
  const atkBon  = baseAtk + (G.heat || 0);
  return newUnit({
    ...template,
    atk: template.atk + atkBon,
    hp:  template.hp  + hpBon,
  });
}

// â”€â”€ SCOUTING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function scout() {
  if (G.gold < 1 || G.scouted || G.phase !== 'shop') return;
  G.gold   -= 1;
  G.scouted = true;

  const board    = G.eboard;
  if (!board.length) return;
  G.scoutedUnit  = board[Math.floor(Math.random() * board.length)];

  render();
}

// â”€â”€ ROUND INIT HOOK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function initRoundOpponents(round) {
  G.scouted     = false;
  G.scoutedUnit = null;

  const nextBoss = getBoss(round + 1);
  G.upcomingBoss = nextBoss ? nextBoss.warning : null;

  G.eboard = buildGhostBoard(round);
}

// â”€â”€ BOSS PRE-COMBAT EFFECT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function applyBossEffect(round) {
  const boss = getBoss(round);
  if (!boss) return null;
  boss.effect(G.cb.pb, G.cb.eb);
  return boss.effectLog;
}
===== render.js =====
import { KW }                            from './data.js';
import { G, polColor, polLabel,
         polAvg, polBonus, enemyThreat } from './state.js';
import { startCombat }                  from './combat.js';
import { reroll, upgradeTavern, buyUnit,
         sellUnit, insightReroll }       from './shop.js';
import { selectCard, targetClick,
         armCard, holdAction }          from './conductor.js';

// â”€â”€ POLARITY METER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderPolMeter() {
  const m = document.getElementById('polmeter');
  if (!G.pboard.length) { m.style.display = 'none'; return; }
  m.style.display = 'flex';
  const avg = polAvg(G.pboard);
  const f   = document.getElementById('polfill');
  f.style.width      = avg + '%';
  f.style.background = polColor(avg);
  document.getElementById('pollabel').textContent = polLabel(avg);
  const bn = polBonus(G.pboard);
  document.getElementById('polbonus').textContent = bn.note ? `(${bn.note})` : '';
}

// â”€â”€ KEYWORD BADGE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function kwBadge(kw) {
  if (!kw) return '';
  const { label, cls } = KW[kw];
  return `<div class="ukw ${cls}">${label}</div>`;
}

// â”€â”€ UNIT CARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function mkUnitHTML(u, { enemy = false, click = false, combat = false, order = 0 } = {}) {
  const pct     = u.chp / u.maxhp;
  const hpColor = pct > .5 ? 'var(--green)' : pct > .25 ? '#ffcc44' : 'var(--red)';

  const cls = [
    'ucard',
    G.cb.attacker?.uid === u.uid         ? 'attacking' : '',
    G.cb.target?.uid   === u.uid         ? 'targeted'  : '',
    G.cb.flashUids?.includes(u.uid)      ? 'flash'     : '',
    u.dead                               ? 'dead'      : '',
    click                                ? 'selectable': '',
    (!enemy && u.lv > 1)                 ? 'lv2'       : '',
  ].join(' ');

  const sell     = (!combat && !enemy) ? `<div class="sellbtn" data-sell="${u.uid}">sell</div>` : '';
  const ent      = u.entropy > 0       ? `<div class="entbadge">${u.entropy}</div>`             : '';
  const ordBadge = combat              ? `<div class="orderbadge">${order}</div>`               : '';
  const lv       = u.lv > 1           ? `<div class="ulv">LV ${u.lv}</div>`                    : '';
  const xpDots   = (!enemy && !combat) ? `<div class="xpdots">${u.xp}/2 XP</div>`              : '';

  return `<div class="${cls}" data-uid="${u.uid}" data-enemy="${enemy ? 1 : 0}">
    ${sell}${ent}${ordBadge}
    <img class="uimg" src="assets/units/${u.id}.png" alt="${u.name}"
         onerror="this.style.display='none';this.nextElementSibling.style.display='block'">
    <div class="usym" style="display:none">${u.sym}</div>
    <div class="uname">${u.name}</div>
    <div class="ustats">
      <span class="uatk">${u.atk}âš”</span>
      <span class="uhp${u.chp < u.maxhp ? ' dmg' : ''}">${u.chp}â™¥</span>
    </div>
    ${lv}${xpDots}${kwBadge(u.kw)}
    <div class="polbar" style="background:${polColor(u.pol)};opacity:.6"></div>
    <div class="hpbar">
      <div class="hpfill" style="width:${Math.max(0, pct) * 100}%;background:${hpColor}"></div>
    </div>
  </div>`;
}

// â”€â”€ SHOP UNIT CARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function mkShopHTML(u, i) {
  const canBuy = G.gold >= u.cost && G.pboard.length < G.maxBoard;
  const kwHtml = u.kw
    ? `<div class="ukw ${KW[u.kw].cls}" style="margin-top:2px">${KW[u.kw].label}</div>`
    : `<div style="height:15px"></div>`;

  return `<div class="${canBuy ? 'sunit' : 'sunit unafford'}" data-buy="${i}">
    <img class="simg" src="assets/units/${u.id}.png" alt="${u.name}"
         onerror="this.style.display='none';this.nextElementSibling.style.display='block'">
    <div style="font-size:1.55em;display:none">${u.sym}</div>
    <div style="font-size:.58em;color:var(--dim);margin-bottom:1px">${u.name}</div>
    <div style="font-size:.64em">
      <span style="color:var(--chaos)">${u.atk}âš”</span>
      <span style="color:var(--green)">${u.hp}â™¥</span>
    </div>
    ${kwHtml}
    <div class="shoppolrow">
      <div class="shoppolbar" style="background:${polColor(u.pol)}"></div>
      <span class="shoppollabel">${polLabel(u.pol)}</span>
    </div>
    <div class="scost">ğŸª™${u.cost}</div>
  </div>`;
}

// â”€â”€ ARM CARD (shop phase) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function mkArmCardHTML(c, isArmed) {
  return `<div class="ccard${isArmed ? ' armed' : ''}" ${isArmed ? '' : `data-arm="${c.id}"`}>
    <img class="cimg" src="assets/cards/${c.id}.png" alt="${c.name}"
         onerror="this.style.display='none';this.nextElementSibling.style.display='block'">
    <span class="csym" style="display:none">${c.sym}</span>
    <span class="cname">${c.name}</span>
    <span class="cdesc">${c.desc}</span>
  </div>`;
}

function renderArmSection() {
  if (G.armedCard) {
    return `<div class="arm-section">
      <div class="arm-label">Armed<br><span class="arm-note">Retained from Hold</span></div>
      ${mkArmCardHTML(G.armedCard, true)}
    </div>`;
  }
  if (G.cardOptions.length) {
    return `<div class="arm-section">
      <div class="arm-label">Arm a card</div>
      ${G.cardOptions.map(c => mkArmCardHTML(c, false)).join('')}
    </div>`;
  }
  return '';
}

// â”€â”€ BOARD RENDERER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderBoard(units, enemy) {
  const inCombat = G.phase === 'combat' || G.phase === 'result';
  const board    = inCombat ? (enemy ? G.cb.eb : G.cb.pb) : units;
  if (!board.length) return `<div class="slot">â€”</div>`;

  const fc           = G.csel && !G.cused;
  const clickEnemy   = fc && G.csel.tgt === 'enemy';
  const clickFriendly= fc && G.csel.tgt === 'friendly';
  const click        = enemy ? clickEnemy : clickFriendly;

  return board.map((u, i) =>
    mkUnitHTML(u, { enemy, click, combat: inCombat, order: i + 1 })
  ).join('');
}

// â”€â”€ SHOP PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderShop() {
  const b          = polBonus(G.pboard);
  const canUpgrade = G.tavernTier < 2 && G.gold >= 4;
  const canReroll  = G.gold >= 1;

  return `
    ${G.shop.map((u, i) => mkShopHTML(u, i)).join('')}
    <div class="shop-actions">
      ${b.note ? `<div class="bonus-note">â—ˆ ${b.note}</div>` : ''}
      <div class="tier-note">Tier ${G.tavernTier} Â· ${G.pboard.length}/${G.maxBoard}</div>
      <button class="btn" id="rerollbtn"  ${canReroll  ? '' : 'disabled'}>â†» Reroll (1ğŸª™)</button>
      ${G.insight > 0
        ? `<button class="btn" id="insightrerollbtn">â—ˆ Free Reroll</button>`
        : ''}
      ${G.tavernTier < 2
        ? `<button class="btn" id="upgradebtn" ${canUpgrade ? '' : 'disabled'}>â–² Upgrade (4ğŸª™)</button>`
        : ''}
      <button class="btn primary" id="fightbtn" ${!G.armedCard ? 'disabled' : ''}>âš” Fight</button>
    </div>
    ${renderArmSection()}`;
}

// â”€â”€ CONDUCTOR PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderConductor() {
  const w       = G.cb.window && !G.cused;
  const canHold = w && !G.cb.holdUsed;

  const note = G.cused
    ? '<span class="clabel-note">Intervention used.</span>'
    : G.csel
      ? `<span class="clabel-note active">Click a ${G.csel.tgt === 'enemy' ? 'target' : 'friendly'}â€¦</span>`
      : w
        ? '<span class="clabel-note window">â¬¡ Intervene now</span>'
        : '<span class="clabel-note">One card per combat.</span>';

  const holdHtml = canHold
    ? `<div class="hold-wrap">
         <button class="btn hold-btn" data-hold="gold">Hold +ğŸª™</button>
         <button class="btn hold-btn" data-hold="insight">Hold +â—ˆ</button>
       </div>`
    : G.cb.holdUsed
      ? `<div class="hold-wrap"><span class="clabel-note">Held.</span></div>`
      : '';

  const cards = G.chand.map(c => `
    <div class="ccard ${G.cused ? 'cused' : ''} ${G.csel?.id === c.id ? 'csel' : ''} ${w && !G.cused ? 'cwindow' : ''}"
         data-conduct="${c.id}">
      <img class="cimg" src="assets/cards/${c.id}.png" alt="${c.name}"
           onerror="this.style.display='none';this.nextElementSibling.style.display='block'">
      <span class="csym" style="display:none">${c.sym}</span>
      <span class="cname">${c.name}</span>
      <span class="cdesc">${c.desc}</span>
    </div>`).join('');

  return `
    <div class="clabel">
      <div class="clabel-title">Conductor</div>
      ${note}
    </div>
    ${holdHtml}
    ${cards}`;
}

// â”€â”€ MAIN RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function render() {
  document.getElementById('shp').textContent    = G.hp;
  document.getElementById('srd').textContent    = `Round ${G.round}`;
  document.getElementById('sgold').textContent  = G.gold;
  document.getElementById('sgwrap').style.display = G.phase === 'shop' ? 'flex' : 'none';

  // Insight display
  const insEl = document.getElementById('sinsight-wrap');
  insEl.style.display = G.insight > 0 ? 'flex' : 'none';
  document.getElementById('sinsight').textContent = G.insight;

  // Heat display
  const heatEl = document.getElementById('sheat-wrap');
  heatEl.style.display = G.heat > 0 ? 'flex' : 'none';
  document.getElementById('sheat').textContent = G.heat;

  // Threat preview + boss warning
  const th = document.getElementById('threat');
  const bw = document.getElementById('bosswarn');
  if (G.phase === 'shop') {
    th.classList.remove('hidden');
    document.getElementById('threatval').textContent = enemyThreat();
    if (G.upcomingBoss) {
      bw.textContent   = `âš  ${G.upcomingBoss}`;
      bw.style.display = 'block';
    } else {
      bw.style.display = 'none';
    }
  } else {
    th.classList.add('hidden');
    bw.style.display = 'none';
  }

  renderPolMeter();

  const pillMap = {
    shop:   ['Shop',   'pill-shop'],
    combat: ['Combat', 'pill-combat'],
    result: ['Result', 'pill-result'],
  };
  const [pt, pc] = pillMap[G.phase] ?? pillMap.result;
  const ph = document.getElementById('sphase');
  ph.textContent = pt;
  ph.className   = `pill ${pc}`;

  document.getElementById('eboard').innerHTML = renderBoard(G.eboard, true);
  document.getElementById('pboard').innerHTML = renderBoard(G.pboard, false);

  const lb = document.getElementById('logbar');
  const inCombat = G.phase === 'combat' || G.phase === 'result';
  if (inCombat) {
    lb.style.display = 'block';
    document.getElementById('ltext').textContent = G.cb.log;
    document.getElementById('ltag').textContent  = G.cb.over ? '' : G.cb.tag;
  } else {
    lb.style.display = 'none';
  }

  const shopEl = document.getElementById('shop');
  const condEl = document.getElementById('conductor');

  if (G.phase === 'shop') {
    shopEl.style.display = 'flex';
    condEl.style.display = 'none';
    shopEl.innerHTML = renderShop();
    document.getElementById('fightbtn')         ?.addEventListener('click', startCombat);
    document.getElementById('rerollbtn')        ?.addEventListener('click', reroll);
    document.getElementById('upgradebtn')       ?.addEventListener('click', upgradeTavern);
    document.getElementById('insightrerollbtn') ?.addEventListener('click', insightReroll);
  } else if (G.phase === 'combat') {
    shopEl.style.display = 'none';
    condEl.style.display = 'flex';
    condEl.innerHTML = renderConductor();
  } else {
    shopEl.style.display = 'none';
    condEl.style.display = 'none';
  }
}

// â”€â”€ EVENT DELEGATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function initEvents({ onContinue, applyLevelUp }) {
  document.addEventListener('click', e => {
    if (e.target.closest('#tutorial')) return;

    const buy = e.target.closest('[data-buy]');
    if (buy) { buyUnit(+buy.dataset.buy); return; }

    const sell = e.target.closest('[data-sell]');
    if (sell) { e.stopPropagation(); sellUnit(+sell.dataset.sell); return; }

    const arm = e.target.closest('[data-arm]');
    if (arm) { armCard(arm.dataset.arm); return; }

    const hold = e.target.closest('[data-hold]');
    if (hold) { holdAction(hold.dataset.hold); return; }

    const cd = e.target.closest('[data-conduct]');
    if (cd && !G.cused) { selectCard(cd.dataset.conduct); return; }

    const uu = e.target.closest('[data-uid]');
    if (uu && G.csel && !G.cused) {
      targetClick(+uu.dataset.uid, uu.dataset.enemy === '1');
      return;
    }

    if (e.target.closest('#rbtn'))    { onContinue();        return; }
    if (e.target.closest('#lu-atk')) { applyLevelUp('atk'); return; }
    if (e.target.closest('#lu-hp'))  { applyLevelUp('hp');  return; }
  });
}
===== shop.js =====
import { POOL, CARDS }                    from './data.js';
import { G, newUnit, shuffle, goldForRound } from './state.js';
import { registerStartRound }               from './flow.js';
import { initRoundOpponents }               from './opponents.js';
import { render }                           from './render.js';

// â”€â”€ SHOP BUILDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function buildShop() {
  const pool = POOL.filter(u => u.tier <= G.tavernTier);
  const size = G.tavernTier === 1 ? 4 : 5;
  G.shop = shuffle(pool).slice(0, size);
}

// â”€â”€ ROUND START â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function startRound() {
  // Build enemies with current heat, then decay
  initRoundOpponents(G.round);
  G.heat = Math.max(0, G.heat - 1);

  // Apply any gold banked by Hold
  G.gold        = goldForRound(G.round) + G.pendingGold;
  G.pendingGold = 0;

  G.phase = 'shop';
  G.csel  = null;

  // Only offer new arm choices if the card was spent (or first round)
  if (!G.armedCard) {
    G.cardOptions = shuffle(CARDS).slice(0, 3);
  }

  buildShop();
  render();
}

registerStartRound(startRound);

// â”€â”€ BUY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function buyUnit(i) {
  const u = G.shop[i];
  if (!u) return;
  if (G.gold < u.cost || G.pboard.length >= G.maxBoard) return;
  G.gold -= u.cost;
  G.pboard.push(newUnit(u));
  G.shop.splice(i, 1);
  render();
}

// â”€â”€ SELL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function sellUnit(uid) {
  const i = G.pboard.findIndex(u => u.uid === uid);
  if (i < 0) return;
  G.pboard.splice(i, 1);
  G.gold += 1;
  render();
}

// â”€â”€ REROLL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function reroll() {
  if (G.gold < 1) return;
  G.gold--;
  buildShop();
  render();
}

// â”€â”€ INSIGHT REROLL (free) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function insightReroll() {
  if (G.insight < 1) return;
  G.insight--;
  buildShop();
  render();
}

// â”€â”€ TAVERN UPGRADE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function upgradeTavern() {
  if (G.gold < 4 || G.tavernTier >= 2) return;
  G.gold      -= 4;
  G.tavernTier = 2;
  G.maxBoard   = 5;
  buildShop();
  render();
}
===== state.js =====
import { POOL } from './data.js';

// â”€â”€ UID counter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _uid = 0;

// â”€â”€ UNIT FACTORY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function newUnit(template) {
  return {
    ...template,
    uid:     _uid++,
    chp:     template.hp,
    maxhp:   template.hp,
    entropy: 0,
    dead:    false,
    xp:      0,
    lv:      1,
  };
}

// â”€â”€ GENERAL HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const rand    = a => a[Math.floor(Math.random() * a.length)];
export const shuffle = a => [...a].sort(() => Math.random() - 0.5);
export const living  = b => b.filter(u => !u.dead && u.chp > 0);
export const tauntOf = b => living(b).find(u => u.kw === 'taunt');

// â”€â”€ POLARITY HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function polAvg(board) {
  if (!board.length) return 50;
  return board.reduce((s, u) => s + u.pol, 0) / board.length;
}

export function polColor(p) {
  const r = Math.round(58  + (255 - 58)  * (p / 100));
  const g = Math.round(112 - 74          * (p / 100));
  const b = Math.round(255 - (255 - 80)  * (p / 100));
  return `rgb(${r},${g},${b})`;
}

export function polLabel(p) {
  return p > 65 ? 'Chaos' : p < 35 ? 'Order' : 'Flux';
}

export function polBonus(board) {
  if (!board.length) return { atk: 0, hp: 0, note: null };
  const avg = polAvg(board);
  if (avg >= 40 && avg <= 60) return { atk: 2, hp: 0, note: '+2 ATK' };
  if (avg  < 30 || avg  > 70) return { atk: 0, hp: 2, note: '+2 HP'  };
  return { atk: 0, hp: 0, note: null };
}

// â”€â”€ GLOBAL STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const G = {
  phase:      'shop',
  round:      1,
  hp:         30,
  gold:       3,
  tavernTier: 1,
  maxBoard:   4,

  pboard: [],
  eboard: [],
  shop:   [],

  // â”€â”€ Intervention economy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  armedCard:   null,    // card committed this run; null = must re-arm
  cardOptions: [],      // 3 choices shown in shop for arming
  chand:       [],      // what appears in the conductor panel (always [armedCard])
  cused:       false,   // whether the card was played this combat
  csel:        null,    // currently selected card object

  pendingGold: 0,       // earned by Hold, applied at next shop start
  insight:     0,       // micro-resource, cap 2; spend for free reroll
  heat:        0,       // rises on intervention (cap 3), boosts enemy ATK

  pboardSnapshot: [],
  levelQueue:     [],

  // Combat sub-state
  cb: {
    pb:         [],
    eb:         [],
    log:        '',
    tag:        '',
    attacker:   null,
    target:     null,
    pturn:      false,
    tickIdx:    0,
    over:       false,
    result:     null,
    flashUids:  [],
    window:     false,
    holdUsed:   false,  // Hold reward already claimed this window
  },
};

// â”€â”€ STATE HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export const cloneUnit = u => ({ ...u });

export function enemyThreat() {
  return G.eboard.reduce((s, u) => s + u.atk, 0);
}

export function goldForRound(round) {
  return 3 + Math.min(round - 1, 7);
}

export function resetCombatState() {
  Object.assign(G.cb, {
    pb: [], eb: [], log: '', tag: '',
    attacker: null, target: null, pturn: false,
    tickIdx: 0, over: false, result: null,
    flashUids: [], window: false,
    holdUsed: false,
  });
  G._fluxRedirectUsed = false;
}

export function initStarterBoard() {
  G.pboard.push(newUnit(POOL.find(u => u.id === 'rifter')));
  G.pboard.push(newUnit(POOL.find(u => u.id === 'tendril')));
}
===== styles.css =====
/* â”€â”€ RESET + TOKENS â”€â”€ */
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#07070f;--surface:#10101e;--border:#252538;
  --gold:#c8a044;--text:#b0a898;--dim:#4a4560;
  --chaos:#ff3a50;--entropy:#44ffaa;
  --green:#44dd88;--red:#ff4455;
}
body{background:var(--bg);color:var(--text);font-family:Georgia,serif;
     height:100vh;display:flex;flex-direction:column;overflow:hidden;user-select:none}

/* â”€â”€ TOPBAR â”€â”€ */
#topbar{display:flex;align-items:center;justify-content:space-between;
        padding:7px 16px;border-bottom:1px solid var(--border);
        background:var(--surface);flex-shrink:0;gap:10px;flex-wrap:wrap}
.title{font-size:1em;letter-spacing:.4em;color:var(--gold);text-transform:uppercase}
.stats{display:flex;gap:14px;font-size:.8em;align-items:center;flex-wrap:wrap}
.stat{display:flex;align-items:center;gap:4px}
.sicon{color:var(--gold)}.sval{color:#fff;font-weight:bold}
.threat{font-size:.75em;padding:2px 8px;border-radius:3px;
        background:rgba(255,58,80,.1);border:1px solid rgba(255,58,80,.25);color:#ff8090}
.threat.hidden{display:none}
.boss-warn{font-size:.72em;padding:2px 8px;border-radius:3px;
           background:rgba(200,160,68,.12);border:1px solid rgba(200,160,68,.4);
           color:var(--gold);display:none}
.polmeter{display:flex;align-items:center;gap:5px;font-size:.75em}
.poltrack{width:52px;height:4px;background:var(--border);border-radius:3px;overflow:hidden}
.polfill{height:100%;border-radius:3px;transition:width .4s,background .4s}
.pollabel{color:var(--dim);min-width:26px;font-size:.9em}
.polbonus{color:var(--gold);font-size:.85em}
.pill{padding:2px 9px;border-radius:20px;font-size:.65em;
      letter-spacing:.12em;text-transform:uppercase;font-weight:bold}
.pill-shop  {background:rgba(200,160,68,.12);color:var(--gold);border:1px solid rgba(200,160,68,.4)}
.pill-combat{background:rgba(255,58,80,.12);color:var(--chaos);border:1px solid rgba(255,58,80,.4)}
.pill-result{background:rgba(68,255,170,.1);color:var(--entropy);border:1px solid rgba(68,255,170,.3)}

/* â”€â”€ MAIN â”€â”€ */
#main{flex:1;display:flex;flex-direction:column;padding:9px 13px;gap:5px;overflow:hidden}
.blabel{font-size:.63em;letter-spacing:.2em;color:var(--dim);
        text-transform:uppercase;margin-bottom:3px}
.board{display:flex;gap:7px;align-items:flex-end;min-height:114px;flex-wrap:wrap}
.slot{width:82px;height:108px;border:1px dashed var(--border);border-radius:6px;
      display:flex;align-items:center;justify-content:center;
      color:var(--dim);font-size:.65em}

/* â”€â”€ UNIT CARDS â”€â”€ */
.ucard{width:82px;min-height:108px;background:var(--surface);
       border:1px solid var(--border);border-radius:6px;
       display:flex;flex-direction:column;align-items:center;
       padding:6px 4px 5px;position:relative;overflow:hidden;
       transition:border-color .15s,transform .12s}
.ucard.attacking{border-color:var(--chaos);transform:scale(1.07);z-index:2}
.ucard.targeted {border-color:var(--red)}
.ucard.dead     {opacity:.2;filter:grayscale(1)}
.ucard.selectable{border-color:var(--gold);
                   box-shadow:0 0 9px rgba(200,160,68,.45);cursor:pointer}
.ucard.selectable:hover{box-shadow:0 0 16px rgba(200,160,68,.65)}
.ucard.lv2{border-color:rgba(200,160,68,.5)}
@keyframes flashRed{0%{background:rgba(255,60,80,.45)}100%{background:transparent}}
.ucard.flash{animation:flashRed .5s ease-out}

/* Unit image (replaces unicode sym when art is available) */
.uimg{width:48px;height:48px;image-rendering:pixelated;margin-bottom:2px}
/* Fallback symbol shown when no image is present */
.usym{font-size:1.7em;line-height:1;margin-bottom:2px}

.uname{font-size:.56em;letter-spacing:.02em;color:var(--dim);
       text-align:center;margin-bottom:2px}
.ustats{display:flex;gap:5px;font-size:.74em}
.uatk{color:var(--chaos)}.uhp{color:var(--green)}.uhp.dmg{color:#ffcc44}
.ulv{font-size:.48em;color:var(--gold);letter-spacing:.06em;margin-top:1px}
.xpdots{font-size:.44em;color:var(--gold);margin-top:1px}
.ukw{font-size:.5em;font-weight:bold;padding:1px 4px;border-radius:3px;
     margin-top:2px;letter-spacing:.03em}
.kw-taunt    {background:rgba(58,111,255,.18);color:#6699ff;border:1px solid rgba(58,111,255,.3)}
.kw-haste    {background:rgba(255,200,68,.13);color:var(--gold);border:1px solid rgba(255,200,68,.28)}
.kw-retaliate{background:rgba(255,58,80,.13);color:#ff8090;border:1px solid rgba(255,58,80,.28)}
.kw-leech    {background:rgba(68,255,170,.1);color:var(--entropy);border:1px solid rgba(68,255,170,.22)}
.polbar{position:absolute;bottom:0;left:0;right:0;height:3px}
.hpbar{position:absolute;bottom:3px;left:4px;right:4px;height:2px;
       background:#181828;border-radius:1px}
.hpfill{height:100%;border-radius:1px;transition:width .3s}
.entbadge{position:absolute;top:2px;right:2px;background:var(--entropy);
          color:#020f06;font-size:.52em;font-weight:bold;width:12px;height:12px;
          border-radius:50%;display:flex;align-items:center;justify-content:center}
.orderbadge{position:absolute;top:2px;left:2px;background:var(--surface);
            border:1px solid var(--border);color:var(--dim);font-size:.48em;
            font-weight:bold;width:12px;height:12px;border-radius:50%;
            display:flex;align-items:center;justify-content:center}
.sellbtn{position:absolute;bottom:17px;left:2px;font-size:.48em;color:var(--chaos);
         border:1px solid var(--chaos);border-radius:2px;padding:1px 3px;
         cursor:pointer;background:var(--bg);opacity:0;transition:opacity .2s;z-index:2}
.ucard:hover .sellbtn{opacity:1}

/* â”€â”€ LOG BAR â”€â”€ */
#logbar{background:var(--surface);border:1px solid var(--border);
        border-radius:4px;overflow:hidden;flex-shrink:0;display:none}
#loginner{display:flex;align-items:center;gap:9px;padding:6px 11px;font-size:.77em}
.logtext{flex:1}
.logtag{color:var(--dim);font-size:.8em;letter-spacing:.1em;
        text-transform:uppercase;white-space:nowrap}
#timertrack{height:2px;background:var(--border)}
#timerfill{height:100%;background:var(--gold);width:0%;transition:none}

/* â”€â”€ BOTTOM / SHOP â”€â”€ */
#bottom{flex-shrink:0;padding-top:5px;border-top:1px solid var(--border)}
#shop{display:flex;gap:7px;align-items:flex-start;flex-wrap:wrap}
.sunit{width:82px;background:var(--surface);border:1px solid var(--border);
       border-radius:6px;padding:6px 4px 5px;cursor:pointer;text-align:center;
       transition:border-color .15s}
.sunit:hover:not(.unafford){border-color:var(--gold)}
.sunit.unafford{opacity:.42;cursor:not-allowed}
.scost{font-size:.68em;color:var(--gold);margin-top:2px}
.shoppolrow{display:flex;align-items:center;gap:3px;margin-top:2px}
.shoppolbar{flex:1;height:3px;border-radius:2px}
.shoppollabel{font-size:.48em;color:var(--dim)}

/* Shop card image */
.simg{width:40px;height:40px;image-rendering:pixelated;margin-bottom:2px}

.shop-actions{display:flex;flex-direction:column;gap:5px;
              margin-left:auto;align-items:flex-end;min-width:90px}
.bonus-note{font-size:.63em;color:var(--gold)}
.tier-note{font-size:.6em;color:var(--dim)}
.btn{padding:5px 12px;border:1px solid var(--border);background:var(--surface);
     color:var(--text);font-family:Georgia,serif;font-size:.76em;cursor:pointer;
     letter-spacing:.04em;transition:border-color .15s,color .15s;border-radius:3px}
.btn:hover{border-color:var(--gold);color:var(--gold)}
.btn.primary{border-color:rgba(200,160,68,.5);color:var(--gold)}
.btn.primary:hover{background:rgba(200,160,68,.08)}
.btn:disabled{opacity:.35;cursor:not-allowed;pointer-events:none}

/* â”€â”€ CONDUCTOR â”€â”€ */
#conductor{display:flex;gap:7px;align-items:flex-start}
.clabel{display:flex;flex-direction:column;gap:3px;
        justify-content:center;min-width:86px}
.clabel-title{font-size:.63em;letter-spacing:.14em;color:var(--dim);text-transform:uppercase}
.clabel-note{font-size:.6em;color:var(--dim);line-height:1.4}
.clabel-note.active{color:var(--gold)}
.clabel-note.window{color:var(--entropy)}
.ccard{width:92px;background:var(--surface);border:1px solid #2a2a44;
       border-radius:6px;padding:6px;cursor:pointer;
       transition:border-color .15s,box-shadow .15s;text-align:center}
.ccard:hover:not(.cused){border-color:var(--gold)}
.ccard.csel{border-color:var(--gold);box-shadow:0 0 10px rgba(200,160,68,.35)}
.ccard.cused{opacity:.4;cursor:not-allowed}
.ccard.cwindow:not(.cused){border-color:rgba(68,255,170,.5);
                            box-shadow:0 0 8px rgba(68,255,170,.2)}

/* Conductor card image (replaces csym when art is available) */
.cimg{width:40px;height:40px;image-rendering:pixelated;margin-bottom:2px}
.csym{font-size:1.25em;display:block;margin-bottom:2px;color:var(--gold)}

.cname{font-size:.63em;color:#fff;font-weight:bold;display:block;margin-bottom:2px}
.cdesc{font-size:.53em;color:var(--dim);line-height:1.3}

/* â”€â”€ OVERLAYS â”€â”€ */
#overlay,#tutorial,#levelup{
  position:fixed;inset:0;background:rgba(7,7,15,.9);
  display:none;flex-direction:column;align-items:center;
  justify-content:center;gap:14px;z-index:100}
.rtitle{font-size:1.8em;letter-spacing:.3em;text-transform:uppercase}
.rtitle.win {color:var(--gold)}
.rtitle.loss{color:var(--chaos)}
.rtitle.draw{color:var(--dim)}
.rsub{font-size:.8em;color:var(--dim);text-align:center;
      max-width:300px;line-height:1.7}

/* â”€â”€ TUTORIAL â”€â”€ */
.tbox{background:var(--surface);border:1px solid var(--border);
      border-radius:8px;padding:26px 30px;max-width:400px;
      display:flex;flex-direction:column;gap:13px}
.tstep{font-size:.6em;letter-spacing:.22em;text-transform:uppercase;color:var(--dim)}
.ttitle{font-size:1.2em;color:var(--gold);letter-spacing:.07em}
.tbody{font-size:.8em;color:var(--text);line-height:1.75}
.tbody strong{color:#fff}
.kw-inline{font-size:.85em;font-weight:bold;padding:1px 5px;border-radius:3px}
.tfoot{display:flex;justify-content:space-between;align-items:center;margin-top:4px}
.tdots{display:flex;gap:5px}
.tdot{width:6px;height:6px;border-radius:50%;background:var(--border)}
.tdot.active{background:var(--gold)}

/* â”€â”€ LEVEL-UP â”€â”€ */
.lubox{background:var(--surface);border:1px solid var(--gold);
       border-radius:8px;padding:26px 30px;max-width:340px;
       display:flex;flex-direction:column;align-items:center;gap:14px}
.lutitle{font-size:1em;letter-spacing:.3em;text-transform:uppercase;color:var(--gold)}
.lusub{font-size:.78em;color:var(--dim);text-align:center}
.luchoices{display:flex;gap:12px}
.luchoice{width:110px;background:var(--bg);border:1px solid var(--border);
          border-radius:6px;padding:12px 8px;cursor:pointer;text-align:center;
          transition:border-color .15s}
.luchoice:hover{border-color:var(--gold)}
.luchoice-icon{font-size:1.6em;margin-bottom:5px}
.luchoice-label{font-size:.7em;color:var(--gold);font-weight:bold}
.luchoice-desc{font-size:.6em;color:var(--dim);margin-top:2px}

/* â”€â”€ SCOUT REVEAL â”€â”€ */
.scout-reveal{display:flex;align-items:center;gap:8px;
              font-size:.72em;color:var(--dim);margin-top:4px}
.scout-reveal strong{color:var(--gold)}

/* â”€â”€ ARM SECTION (shop phase) â”€â”€ */
.arm-section{display:flex;gap:7px;align-items:flex-start;flex-wrap:wrap;
             padding:7px 0 0;margin-top:5px;
             border-top:1px solid var(--border);width:100%}
.arm-label{font-size:.6em;letter-spacing:.12em;color:var(--dim);
           text-transform:uppercase;align-self:center;
           min-width:60px;line-height:1.5}
.arm-note{color:rgba(68,255,170,.5);font-size:.9em;letter-spacing:0;
          text-transform:none;display:block}

/* Armed card state â€” glows entropy-green, no pointer events */
.ccard.armed{border-color:rgba(68,255,170,.45);
             box-shadow:0 0 7px rgba(68,255,170,.18);
             cursor:default;pointer-events:none}

/* â”€â”€ HOLD ACTIONS (combat window) â”€â”€ */
.hold-wrap{display:flex;flex-direction:column;gap:5px;
           justify-content:center;min-width:80px}
.hold-btn{font-size:.62em;padding:4px 8px;
          white-space:nowrap;text-align:center}
===== tutorial.js =====
import { TUTORIAL } from './data.js';

// â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _step = 0;

// â”€â”€ RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderStep() {
  const s = TUTORIAL[_step];
  document.getElementById('tstep').textContent  = `Step ${_step + 1} of ${TUTORIAL.length}`;
  document.getElementById('ttitle').textContent = s.title;
  document.getElementById('tbody').innerHTML    = s.body;
  document.getElementById('tdots').innerHTML    = TUTORIAL
    .map((_, i) => `<div class="tdot${i === _step ? ' active' : ''}"></div>`)
    .join('');
  document.getElementById('tnext').textContent  =
    _step < TUTORIAL.length - 1 ? 'Next â†’' : 'Play â†’';
}

// â”€â”€ ADVANCE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function advance() {
  if (_step < TUTORIAL.length - 1) {
    _step++;
    renderStep();
  } else {
    document.getElementById('tutorial').style.display = 'none';
  }
}

// â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Called once from index.html after the DOM is ready.
export function initTutorial() {
  renderStep();
  document.getElementById('tnext').addEventListener('click', advance);
  document.getElementById('tutorial').style.display = 'flex';
}